//
//* 23 - 5找到一个大邮件，并分别用multimap和unordered_multimap输出所有邮件信息，对比两者所花费的时间。
//首先本人尝试去找了大邮件，好像根本找不到。虽然qq邮件比较多，但是不符合要求。在此只比较两者的性能，发现这块内容有点生疏，趁此机会再复习一下。
//[]先介绍一下vector，为什么呢？因为unordered_map就是利用vector实现的，计算关键字在vector中的索引值。
//[]vector是用矩阵实现的，其平均查找代价与vector(N)的长度成比例。这个代价称之为O(N)。
//[]map是用红黑树实现的，其平均查找代价与树的深度成比例，一颗有N个节点的平衡二叉树的最大深度为log2(N)，
//代价为O(log2(N))。2的N次方为节点数近似值。与O(N)相比是非常好的，但是追踪指针(map查找)的代价比递增指针(find()在vector中所做的)大得多。
//[]unordered_map是用哈希表实现的，是散列的存储方式。这种技术用来应对关键字数量远大于哈希表中的位置的情况，例如数十亿个可能的字符串映射成1000个元素的vector中的索引。其优点是查找的平均代价与表中的元素数量无关！！！即O(1)。
//[]multimap是用红黑树实现，而unordered_multimap是用哈希表实现的。前者代价与map近似为log2(N)，后者代价与unordered_map近似为O(1)。
//[]总结虽然这几个map实现方式和性能不同，但是也有相应的使用经验法则。
//*除非有好的理由，否则用vecor。
//*如果需要基于值来进行查找，而且关键字类型有合理而高效的小于操作（例如关键字为string或者int类型）。这时使用map
//*如果需要在一个大的映射中进行大量查找，而且不需要有序的遍历，并且可以为关键字类型找到一个好的哈希函数，这时使用unordered_map。

